<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep-space: #0f0c29;
            --bg-nebula-start: #24243e;
            --bg-nebula-end: #302b63;
            --surface-color: rgba(20, 20, 50, 0.7); /* Frosted glass effect */
            --surface-border: rgba(100, 100, 220, 0.3);
            --text-primary: #e0e0ff;
            --text-secondary: #b0b0d0;
            --accent-cyan: #00e5ff;
            --accent-magenta: #ff00ff;
            --accent-glow: rgba(0, 229, 255, 0.5);
            --path-color: var(--accent-magenta);
            --button-bg: linear-gradient(145deg, var(--accent-cyan), var(--accent-magenta));
            --button-hover-bg: linear-gradient(145deg, #00cfff, #e600e6);
            --font-main: 'Montserrat', sans-serif;
            --font-title: 'Orbitron', sans-serif;
            --border-radius: 10px;
            --box-shadow-soft: 0 4px 15px rgba(0,0,0,0.2);
            --box-shadow-glow: 0 0 15px var(--accent-glow);
        }

        /* Simple SVG Icons - Styled for dark theme */
        .icon svg { width: 1em; height: 1em; fill: var(--accent-cyan); margin-right: 8px; vertical-align: -0.15em; }

        body {
            font-family: var(--font-main);
            margin: 0;
            padding: 20px;
            background-color: var(--bg-deep-space);
            background-image: linear-gradient(to bottom right, var(--bg-nebula-start), var(--bg-nebula-end));
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-size: 15px;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .main-container {
            background-color: var(--surface-color);
            backdrop-filter: blur(10px); /* Frosted glass */
            -webkit-backdrop-filter: blur(10px); /* Safari */
            border: 1px solid var(--surface-border);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-soft);
            padding: 30px;
            width: 95%;
            max-width: 1200px; /* Increased max-width to help fit 4 columns */
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        header h1 {
            font-family: var(--font-title);
            color: var(--text-primary);
            text-align: center;
            font-size: 2.8em;
            margin-bottom: 5px;
            letter-spacing: 1px;
            text-shadow: 0 0 10px var(--accent-glow);
        }
        header p {
            text-align: center;
            color: var(--text-secondary);
            font-size: 1em;
            margin-top: 0;
            margin-bottom: 25px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Default to 4 columns */
            gap: 20px;
        }

        .control-group {
            background-color: rgba(30, 30, 60, 0.5); /* Darker frosted glass */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--surface-border);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group h3 {
            font-family: var(--font-title);
            font-size: 0.9em; /* Slightly smaller for fitting */
            color: var(--accent-cyan);
            margin: 0 0 10px 0;
            border-bottom: 1px solid var(--surface-border);
            padding-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
        }

        .control-group label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .control-group input[type="file"],
        .control-group input[type="number"],
        .control-group button {
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--surface-border);
            background-color: rgba(10, 10, 30, 0.7);
            color: var(--text-primary);
            font-family: var(--font-main);
            font-size: 0.95em;
            transition: all 0.2s ease;
        }
        .control-group input[type="file"]::file-selector-button {
            background: var(--button-bg);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-weight: 600;
        }
         .control-group input:focus, .control-group button:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 8px var(--accent-glow);
        }

        .control-group button {
            background: var(--button-bg);
            color: white;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            border: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .control-group button:hover {
            background: var(--button-hover-bg);
            box-shadow: var(--box-shadow-glow);
        }
        .control-group button.active {
            background: linear-gradient(145deg, var(--accent-magenta), #c000c0);
        }
        .control-group button#downloadButton {
            background: linear-gradient(145deg, #4CAF50, #2E7D32);
        }
         .control-group button#downloadButton:hover {
            background: linear-gradient(145deg, #66BB6A, #388E3C);
        }


        .info-bar {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            padding: 10px 15px;
            background-color: rgba(30, 30, 60, 0.6);
            border: 1px solid var(--surface-border);
            border-radius: 8px;
            font-size: 0.95em;
        }
        .info-bar p { margin: 5px;}
        .info-bar span {
            color: var(--accent-cyan);
            font-weight: 600;
        }

        #status-container {
            padding: 12px 15px;
            background-color: rgba(30, 30, 60, 0.6);
            border: 1px solid var(--surface-border);
            border-radius: 8px;
            text-align: center;
            min-height: 24px;
            font-family: var(--font-main);
            font-weight: 500;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        #status { min-height: 1.2em; display: inline-block; } 
        .status-loader {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 229, 255, 0.2);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: none; /* Hidden by default */
        }
        @keyframes spin { to { transform: rotate(360deg); } }


        .maze-display-area {
            position: relative;
            width: 100%;
            max-width: 700px; 
            margin: 20px auto 0 auto; 
            border: 1px solid var(--surface-border);
            border-radius: 8px;
            overflow: hidden; 
            background-color: rgba(10,10,20,0.8); 
            box-shadow: var(--box-shadow-soft);
        }
        #mazeImage { display: block; width: 100%; height: auto; opacity: 0.7; }
        #solutionCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; }
        

        /* Responsive Grid for Controls */
        @media (max-width: 1100px) { /* Tablets and smaller desktops */
            .controls-grid { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) { /* Mobile */
            .main-container { padding: 15px; margin-top: 10px;}
            header h1 { font-size: 2em; }
            .controls-grid { grid-template-columns: 1fr; }
            .info-bar { flex-direction: column; align-items: center; gap: 5px; }
            .control-group {padding: 15px;}
            body { font-size: 14px; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>Maze Solver</h1>
            <p>Navigate the cosmic labyrinth. Upload your star chart and find the celestial path.</p>
        </header>

        <div class="controls-grid">
            <div class="control-group">
                <h3><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg></span>1. Load Star Chart</h3>
                <label for="imageUpload">Upload Maze Image:</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>

            <div class="control-group">
                <h3><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.48 12.04c-.3-.31-.79-.31-1.09 0l-2.83 2.83-1.41-1.41c1.16-1.16 1.16-3.05 0-4.21l-1.41-1.41c-.3-.31-.79-.31-1.09 0s-.31.79 0 1.09l1.41 1.41c.58.58.58 1.53 0 2.11L12 15.06l-2.83-2.83c-.58-.58-.58-1.53 0-2.11l1.41-1.41c.3-.31.3-.81 0-1.11s-.79-.31-1.09 0l-1.41 1.41c-1.16 1.16-1.16 3.05 0 4.21l1.41 1.41L12 17.9l2.83-2.83c1.16-1.16 1.16-3.05 0-4.21l-1.41-1.41c-.3-.3-.3-.79 0-1.09s.79-.3 1.09 0l1.41 1.41c.58.58.58 1.53 0 2.11L14.94 15.06l2.83-2.83c.3-.3.3-.79 0-1.09zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg></span>2. Scanner Config</h3>
                <label for="cellSize" title="Resolution of the scan. Smaller values are more detailed but slower.">Detail Level (Cell Size px):</label>
                <input type="number" id="cellSize" value="3" min="1" max="50">
                <label for="pathThreshold" title="Brightness threshold (0-255) to distinguish paths (brighter) from walls (darker).">Signal Threshold:</label>
                <input type="number" id="pathThreshold" value="128" min="0" max="255">
            </div>

            <div class="control-group">
                <h3><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg></span>3. Set Waypoints</h3>
                <button id="autoDetectButton">Auto-Detect Waypoints</button>
                <button id="setStartButton">Set Origin Manually</button>
                <button id="setEndButton">Set Destination Manually</button>
            </div>
             <div class="control-group">
                <h3><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 12.17l7.59-7.59L19 6l-9 9z"/></svg></span>4. Engage!</h3>
                <button id="solveShortestButton">Find Hyperlane</button>
                <button id="findAllPathsButton">Explore Nebula (Slow!)</button>
                <button id="downloadButton" style="display:none;">Download Chart</button>
            </div>
        </div>

        <div class="info-bar">
            <p>Origin: <span id="startPointInfo">Undefined</span></p>
            <p>Destination: <span id="endPointInfo">Undefined</span></p>
            <p>Routes Logged: <span id="pathsFoundInfo">None</span></p>
        </div>
        
        <div id="status-container">
            <div class="status-loader" id="statusLoader"></div>
            <span id="status">Awaiting astrogation data...</span>
        </div>
        
        <div class="maze-display-area">
            <img id="mazeImage" src="#" alt="Uploaded Star Chart" style="display:none;">
            <canvas id="solutionCanvas"></canvas>
        </div>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const mazeImage = document.getElementById('mazeImage');
        const solutionCanvas = document.getElementById('solutionCanvas');
        const ctx = solutionCanvas.getContext('2d');
        
        const cellSizeInput = document.getElementById('cellSize');
        const pathThresholdInput = document.getElementById('pathThreshold');
        const autoDetectButton = document.getElementById('autoDetectButton');
        const setStartButton = document.getElementById('setStartButton');
        const setEndButton = document.getElementById('setEndButton');
        const solveShortestButton = document.getElementById('solveShortestButton');
        const findAllPathsButton = document.getElementById('findAllPathsButton');
        const downloadButton = document.getElementById('downloadButton');
        const statusSpan = document.getElementById('status');
        const statusLoader = document.getElementById('statusLoader');
        const startPointInfo = document.getElementById('startPointInfo');
        const endPointInfo = document.getElementById('endPointInfo');
        const pathsFoundInfo = document.getElementById('pathsFoundInfo');

        let originalImage = null;
        let imageDisplayedWidth = 0;
        let imageDisplayedHeight = 0;
        let mazeGrid = [];
        let gridWidth, gridHeight;
        let startCoords = null;
        let endCoords = null;
        let settingMode = null; 
        let currentSolutionPath = null;
        let typeAwaitTimeout = null;

        const PATH_COLOR_JS = getComputedStyle(document.documentElement).getPropertyValue('--path-color').trim();
        const ACCENT_CYAN_JS = getComputedStyle(document.documentElement).getPropertyValue('--accent-cyan').trim();
        const ERROR_COLOR_JS = '#ff4444'; // A more vibrant red for dark theme
        const SUCCESS_COLOR_JS = '#00C851'; // A vibrant green

        const MAX_PATHS_TO_FIND = 500;
        const MAX_DFS_SEARCH_TIME_MS = 15000; 
        let dynamicStatusInterval = null;
        let currentStatusTypewriterController = null;

        function typeWriter(element, text, speed = 50) {
            return new Promise((resolve) => {
                let i = 0;
                element.innerHTML = ''; 
                let aborted = false;
                const controller = { abort: () => { aborted = true; } };

                if (currentStatusTypewriterController) currentStatusTypewriterController.abort();
                currentStatusTypewriterController = controller;

                function type() {
                    if (aborted) { element.innerHTML = text; resolve(); return; }
                    if (i < text.length) {
                        element.innerHTML += text.charAt(i); i++;
                        typeAwaitTimeout = setTimeout(type, speed);
                    } else { currentStatusTypewriterController = null; resolve(); }
                }
                type();
            });
        }

        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    mazeImage.src = e.target.result;
                    mazeImage.style.display = 'block';
                    originalImage = new Image();
                    originalImage.onload = () => {
                        solutionCanvas.width = originalImage.naturalWidth;
                        solutionCanvas.height = originalImage.naturalHeight;
                        imageDisplayedWidth = mazeImage.offsetWidth;
                        imageDisplayedHeight = mazeImage.offsetHeight;
                        ctx.clearRect(0, 0, solutionCanvas.width, solutionCanvas.height);
                        resetState();
                        updateStatus('Star chart loaded. Configure scanners or set waypoints.');
                        downloadButton.style.display = 'none';
                        currentSolutionPath = null;
                    }
                    originalImage.src = e.target.result;
                }
                reader.readAsDataURL(file);
            }
        });

        window.addEventListener('resize', () => {
            if (originalImage && mazeImage.style.display === 'block') {
                imageDisplayedWidth = mazeImage.offsetWidth;
                imageDisplayedHeight = mazeImage.offsetHeight;
                drawPointsAndPath();
            }
        });
        
        function resetState() {
            mazeGrid = []; startCoords = null; endCoords = null; settingMode = null;
            currentSolutionPath = null;
            startPointInfo.textContent = 'Undefined'; endPointInfo.textContent = 'Undefined';
            pathsFoundInfo.textContent = 'None';
            setStartButton.classList.remove('active'); setEndButton.classList.remove('active');
            if(solutionCanvas.width > 0 && solutionCanvas.height > 0) {
                ctx.clearRect(0, 0, solutionCanvas.width, solutionCanvas.height);
            }
            updateStatus('Awaiting astrogation data...');
            downloadButton.style.display = 'none';
            stopDynamicStatusUpdates();
        }
        
        async function startDynamicStatusUpdates(initialMessages = [], dynamicCycleMessages = []) {
            stopDynamicStatusUpdates(); 
            statusLoader.style.display = 'block';

            for (const msg of initialMessages) {
                await updateStatus(msg.text, msg.type, msg.speed || 30, false); // Don't hide loader yet
                await new Promise(r => setTimeout(r, 200)); 
            }

            let dynamicIndex = 0;
            if (dynamicCycleMessages.length > 0) {
                dynamicStatusInterval = setInterval(async () => {
                    if (!dynamicStatusInterval) return; 
                    await typeWriter(statusSpan, dynamicCycleMessages[dynamicIndex % dynamicCycleMessages.length], 50);
                    statusSpan.parentElement.style.borderColor = ACCENT_CYAN_JS; // Default processing color
                    dynamicIndex++;
                }, 2200); 
            }
        }

        function stopDynamicStatusUpdates() {
            if (dynamicStatusInterval) clearInterval(dynamicStatusInterval);
            dynamicStatusInterval = null;
            if (currentStatusTypewriterController) {
                currentStatusTypewriterController.abort();
                currentStatusTypewriterController = null;
            }
            statusLoader.style.display = 'none';
        }
        
        autoDetectButton.addEventListener('click', async () => {
            if (!originalImage) { await updateStatus('Load a star chart first, Captain!', 'error'); return; }
            
            startDynamicStatusUpdates(
                [{text: "Initiating automated waypoint scan...", type: 'info', speed: 30}],
                [ 
                    "Analyzing chart peripheries...", "Searching for prominent warp signatures...",
                    "Cross-referencing stellar cartography database...", "Identifying potential origin and destination points..."
                ]
            );

            try {
                await new Promise(resolve => setTimeout(resolve, 50)); 
                buildMazeGrid();
                if (mazeGrid.length === 0 || (mazeGrid[0] && mazeGrid[0].length === 0)) {
                     await updateStatus('Error: Chart grid unreadable for auto-detection.', 'error');
                     stopDynamicStatusUpdates(); return;
                }
                const detectionResult = performAutoDetectionSummary();
                drawPointsAndPath();
                await updateStatus(detectionResult.message, detectionResult.success ? 'success' : 'warning');
            } catch (e) {
                console.error("Error in auto-detection:", e);
                await updateStatus("Anomaly detected during automated scan.", 'error');
            } finally {
                stopDynamicStatusUpdates(); 
            }
        });

        function performAutoDetectionSummary() {
            let S_found = false, E_found = false; startCoords = null; endCoords = null;
            for (let x = 0; x < gridWidth; x++) { if (mazeGrid[0][x]) { startCoords = {x,y:0}; S_found=true; break; }}
            if(!S_found){ for (let y = 0; y < gridHeight; y++) { if (mazeGrid[y][0]) { startCoords = {x:0,y}; S_found=true; break; }}}
            for (let x = gridWidth - 1; x >= 0; x--) { if (mazeGrid[gridHeight-1][x]) { endCoords = {x,y:gridHeight-1}; E_found=true; break; }}
            if(!E_found){ for (let y = gridHeight - 1; y >= 0; y--) { if (mazeGrid[y][gridWidth-1]) { endCoords = {x:gridWidth-1,y}; E_found=true; break; }}}
            
            if (startCoords) startPointInfo.textContent = `(${startCoords.x}, ${startCoords.y})`; else startPointInfo.textContent = 'Undefined';
            if (endCoords) endPointInfo.textContent = `(${endCoords.x}, ${endCoords.y})`; else endPointInfo.textContent = 'Undefined';
            
            let message = ""; let success = false;
            if(S_found && E_found) { message = `Waypoints locked: Origin (${startCoords.x},${startCoords.y}), Dest. (${endCoords.x},${endCoords.y})`; success = true; }
            else if (S_found || E_found) { message = `Partial lock: Origin ${S_found? '('+startCoords.x+','+startCoords.y+')':'N/A'}, Dest. ${E_found? '('+endCoords.x+','+endCoords.y+')':'N/A'}. Verify.`; success = true;}
            else { message = 'Automated waypoint scan inconclusive. Please set manually.'; success = false; }
            return {success, message};
        }


        setStartButton.addEventListener('click', () => {
            if (!originalImage) { updateStatus('Load a star chart first!', 'error'); return; }
            settingMode = 'start'; setStartButton.classList.add('active'); setEndButton.classList.remove('active');
            updateStatus('Click on the chart to set expedition ORIGIN.');
        });

        setEndButton.addEventListener('click', () => {
            if (!originalImage) { updateStatus('Load a star chart first!', 'error'); return; }
            settingMode = 'end'; setEndButton.classList.add('active'); setStartButton.classList.remove('active');
            updateStatus('Click on the chart to set expedition DESTINATION.');
        });

        solutionCanvas.addEventListener('click', (event) => {
            if (!originalImage || !settingMode) return;
            const rect = solutionCanvas.getBoundingClientRect(); 
            const clickX_on_canvas = event.clientX - rect.left; const clickY_on_canvas = event.clientY - rect.top;
            const scaleX = solutionCanvas.width / imageDisplayedWidth; const scaleY = solutionCanvas.height / imageDisplayedHeight;
            const x_on_image = clickX_on_canvas * scaleX; const y_on_image = clickY_on_canvas * scaleY;
            const cellSize = parseInt(cellSizeInput.value);
            const gridX = Math.floor(x_on_image / cellSize); const gridY = Math.floor(y_on_image / cellSize);

            if (settingMode === 'start') {
                startCoords = { x: gridX, y: gridY }; startPointInfo.textContent = `(${gridX}, ${gridY})`;
                updateStatus('Origin waypoint set. Now set destination or engage thrusters!');
                setStartButton.classList.remove('active');
            } else if (settingMode === 'end') {
                endCoords = { x: gridX, y: gridY }; endPointInfo.textContent = `(${gridX}, ${gridY})`;
                updateStatus('Destination waypoint set. Ready to engage!');
                setEndButton.classList.remove('active');
            }
            settingMode = null; currentSolutionPath = null; downloadButton.style.display = 'none';
            drawPointsAndPath();
        });
        
        function drawPointsAndPath() {
            if(solutionCanvas.width === 0 || solutionCanvas.height === 0) return;
            ctx.clearRect(0, 0, solutionCanvas.width, solutionCanvas.height); 
            const cellSize = parseInt(cellSizeInput.value);
            const pointRadius = Math.max(3, cellSize * 0.35); 

            if (currentSolutionPath) drawPath(currentSolutionPath, PATH_COLOR_JS, cellSize);
            if (startCoords) {
                ctx.fillStyle = SUCCESS_COLOR_JS; ctx.beginPath();
                ctx.arc(startCoords.x * cellSize + cellSize / 2, startCoords.y * cellSize + cellSize / 2, pointRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
            if (endCoords) {
                ctx.fillStyle = ERROR_COLOR_JS; ctx.beginPath();
                ctx.arc(endCoords.x * cellSize + cellSize / 2, endCoords.y * cellSize + cellSize / 2, pointRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function drawPath(path, color, cellSize) {
            if (!path || path.length === 0) return;
            ctx.strokeStyle = color; ctx.lineWidth = Math.max(2, Math.floor(cellSize * 0.5)); // Thicker path
            ctx.lineCap = "round"; ctx.lineJoin = "round";
            ctx.shadowColor = color; ctx.shadowBlur = 8; // Path glow
            ctx.beginPath();
            ctx.moveTo(path[0].x * cellSize + cellSize / 2, path[0].y * cellSize + cellSize / 2);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x * cellSize + cellSize / 2, path[i].y * cellSize + cellSize / 2);
            }
            ctx.stroke();
            ctx.shadowColor = "transparent"; ctx.shadowBlur = 0;
        }

        async function commonSolvePreamble(operationName) {
            if (!originalImage) { await updateStatus('Load a star chart first, Captain!', 'error'); return false; }
            if (!startCoords || !endCoords) { await updateStatus('Set both Origin and Destination waypoints.', 'error'); return false; }
            currentSolutionPath = null; downloadButton.style.display = 'none'; pathsFoundInfo.textContent = 'None';
            
            startDynamicStatusUpdates(
                [{text: `Engaging engines for: ${operationName}!`, type: 'success', speed:30}],
                [
                    "Calibrating navigation sensors...", "Plotting primary vector...",
                    "Checking for subspace anomalies...", "Engaging warp field calculations...",
                    "Course computation in progress..."
                ]
            );
            return true;
        }

        solveShortestButton.addEventListener('click', async () => {
            if(!await commonSolvePreamble("Hyperlane Calculation")) return;
            try {
                await new Promise(resolve => setTimeout(resolve, 50)); 
                buildMazeGrid();
                if (!validateGridAndPoints()) { stopDynamicStatusUpdates(); return; }
                
                await updateStatus("Chart grid decoded. Calculating optimal hyperlane...", "info", 40);
                await new Promise(resolve => setTimeout(resolve, 50));

                currentSolutionPath = solveBFS();
                drawPointsAndPath();
                if (currentSolutionPath) {
                    pathsFoundInfo.textContent = '1 (Optimal)';
                    downloadButton.style.display = 'block';
                    await updateStatus('Optimal hyperlane calculated and displayed!', 'success');
                } else { 
                    await updateStatus('No viable hyperlane found between waypoints.', 'error');
                }
            } catch(e) {
                console.error("Error finding shortest path:", e);
                await updateStatus("Navigation computer encountered an anomaly.", "error");
            } finally {
                stopDynamicStatusUpdates();
            }
        });
        
        findAllPathsButton.addEventListener('click', async () => {
            if(!await commonSolvePreamble("Nebula Exploration")) return;
            if (!confirm("WARNING: Full nebula exploration is resource-intensive. Search may be limited by complexity or duration. Proceed with deep scan?")) {
                stopDynamicStatusUpdates();
                await updateStatus('Nebula exploration aborted by user command.', 'warning'); return;
            }
            try {
                await new Promise(resolve => setTimeout(resolve, 50));
                buildMazeGrid();
                if (!validateGridAndPoints()) { stopDynamicStatusUpdates(); return; }

                await updateStatus("Chart grid decoded. Initiating deep nebula scan for all routes...", "info", 40);
                await updateStatus(`(Scan limits: ${MAX_PATHS_TO_FIND} routes or ${MAX_DFS_SEARCH_TIME_MS/1000}s duration)`, "info", 40);
                await new Promise(resolve => setTimeout(resolve, 50));
                
                const result = solveDFS_findAllPaths();
                pathsFoundInfo.textContent = `${result.paths.length}${result.limitReached ? `+ (${result.limitType} limit)`: ''}`;
                if (result.paths.length > 0) {
                    currentSolutionPath = result.paths[Math.floor(Math.random() * result.paths.length)]; 
                    drawPointsAndPath();
                    await updateStatus(`Scan complete: ${result.paths.length} routes logged${result.limitReached ? ' (scan limited)' : ''}. Displaying one.`, 'success');
                    downloadButton.style.display = 'block';
                    if(result.limitReached) {
                        await new Promise(r => setTimeout(r, 100)); 
                        await updateStatus(`Deep scan concluded due to ${result.limitType} protocols.`, 'warning');
                    }
                } else {
                    drawPointsAndPath(); 
                    await updateStatus('Deep scan found no routes between these waypoints.', 'error');
                }
            } catch (e) {
                console.error("Error finding all paths:", e);
                await updateStatus("Subspace interference during deep scan. Results inconclusive.", "error");
            } finally {
                stopDynamicStatusUpdates();
            }
        });
        
        function validateGridAndPoints() {
            if (mazeGrid.length === 0 || (mazeGrid[0] && mazeGrid[0].length === 0)) {
                 updateStatus('Error: Star chart grid undecipherable. Adjust scanner config.', 'error', 50, false); return false;
            }
            if (!isValidPoint(startCoords) || !mazeGrid[startCoords.y][startCoords.x]) {
                 updateStatus('Origin waypoint is in uncharted/obstructed space.', 'error', 50, false); return false;
            }
            if (!isValidPoint(endCoords) || !mazeGrid[endCoords.y][endCoords.x]) {
                 updateStatus('Destination waypoint is in uncharted/obstructed space.', 'error', 50, false); return false;
            }
            return true;
        }

        function isValidPoint(coord) {
            return coord && coord.y >= 0 && coord.y < gridHeight && coord.x >= 0 && coord.x < gridWidth;
        }

        function buildMazeGrid() {
            const cellSize = parseInt(cellSizeInput.value);
            const pathThreshold = parseInt(pathThresholdInput.value);
            gridWidth = Math.floor(originalImage.naturalWidth / cellSize);
            gridHeight = Math.floor(originalImage.naturalHeight / cellSize);
            if (gridWidth <= 0 || gridHeight <= 0) { mazeGrid = []; return; }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImage.naturalWidth; tempCanvas.height = originalImage.naturalHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(originalImage, 0, 0); mazeGrid = [];
            for (let y = 0; y < gridHeight; y++) {
                const row = [];
                for (let x = 0; x < gridWidth; x++) {
                    const sx = x * cellSize; const sy = y * cellSize;
                    const effW = Math.min(cellSize, originalImage.naturalWidth - sx); const effH = Math.min(cellSize, originalImage.naturalHeight - sy);
                    if (effW <= 0 || effH <= 0) { row.push(0); continue; }
                    try {
                        const imageData = tempCtx.getImageData(sx, sy, effW, effH); const data = imageData.data;
                        let sumBrightness = 0; let pixelCount = 0;
                        for (let i = 0; i < data.length; i += 4) { sumBrightness += (data[i] + data[i+1] + data[i+2]) / 3; pixelCount++; }
                        const avgBrightness = pixelCount > 0 ? sumBrightness / pixelCount : 0;
                        row.push(avgBrightness > pathThreshold ? 1 : 0);
                    } catch (e) { row.push(0); }
                }
                mazeGrid.push(row);
            }
        }

        function solveBFS() {
            const queue = [{ x: startCoords.x, y: startCoords.y, path: [] }];
            const visited = new Set([`${startCoords.x},${startCoords.y}`]);
            const directions = [ { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 } ];
            while (queue.length > 0) {
                const current = queue.shift(); const { x, y, path } = current;
                if (x === endCoords.x && y === endCoords.y) return path.concat([{ x, y }]);
                for (const dir of directions) {
                    const nextX = x + dir.dx; const nextY = y + dir.dy;
                    if (isValidPoint({x:nextX, y:nextY}) && mazeGrid[nextY][nextX] === 1 && !visited.has(`${nextX},${nextY}`)) {
                        visited.add(`${nextX},${nextY}`);
                        queue.push({ x: nextX, y: nextY, path: path.concat([{x,y}]) });
                    }
                }
            }
            return null;
        }
        
        function solveDFS_findAllPaths() {
            const allPathsFound = []; const currentPathStack = []; const visitedInThisPath = new Set();
            const startTime = Date.now(); let limitReachedType = null;
            function dfsRecursive(currX, currY) {
                if (allPathsFound.length >= MAX_PATHS_TO_FIND) { limitReachedType = 'max routes'; return; }
                if (Date.now() - startTime > MAX_DFS_SEARCH_TIME_MS) { limitReachedType = 'time limit'; return; }
                currentPathStack.push({x: currX, y: currY}); visitedInThisPath.add(`${currX},${currY}`);
                if (currX === endCoords.x && currY === endCoords.y) {
                    allPathsFound.push([...currentPathStack]); 
                } else {
                    const directions = [ { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 } ]; 
                    for (const dir of directions) {
                        if (limitReachedType) break; 
                        const nextX = currX + dir.dx; const nextY = currY + dir.dy;
                        if (isValidPoint({x:nextX, y:nextY}) && mazeGrid[nextY][nextX] === 1 && !visitedInThisPath.has(`${nextX},${nextY}`)) {
                            dfsRecursive(nextX, nextY);
                        }
                    }
                }
                visitedInThisPath.delete(`${currX},${currY}`); currentPathStack.pop();
            }
            dfsRecursive(startCoords.x, startCoords.y);
            return { paths: allPathsFound, limitReached: !!limitReachedType, limitType: limitReachedType };
        }
        
        downloadButton.addEventListener('click', async () => {
            if (!originalImage || !currentSolutionPath) { await updateStatus('No charted course to download.', 'error'); return; }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImage.naturalWidth; tempCanvas.height = originalImage.naturalHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(originalImage, 0, 0);
            if (currentSolutionPath && currentSolutionPath.length > 0) {
                 const cellSize = parseInt(cellSizeInput.value);
                 drawPathOnContext(tempCtx, currentSolutionPath, PATH_COLOR_JS, cellSize);
            }
            const dataURL = tempCanvas.toDataURL('image/png'); const link = document.createElement('a');
            link.download = 'solved_starmap.png'; link.href = dataURL;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            await updateStatus('Marked star chart downloaded to archives!', 'success');
        });

        function drawPathOnContext(targetCtx, path, color, cellSize) { 
            if (!path || path.length === 0) return;
            targetCtx.strokeStyle = color; targetCtx.lineWidth = Math.max(2, Math.floor(cellSize * 0.5));
            targetCtx.lineCap = "round"; targetCtx.lineJoin = "round";
            targetCtx.shadowColor = color; targetCtx.shadowBlur = 8; targetCtx.shadowOffsetX = 0; targetCtx.shadowOffsetY = 0;
            targetCtx.beginPath();
            targetCtx.moveTo(path[0].x * cellSize + cellSize / 2, path[0].y * cellSize + cellSize / 2);
            for (let i = 1; i < path.length; i++) {
                targetCtx.lineTo(path[i].x * cellSize + cellSize / 2, path[i].y * cellSize + cellSize / 2);
            }
            targetCtx.stroke();
            targetCtx.shadowColor = "transparent"; targetCtx.shadowBlur = 0;
        }
        
        async function updateStatus(message, type = 'info', speed = 30, showLoaderOverride) {
            if (typeof showLoaderOverride === 'undefined') {
                 statusLoader.style.display = (type === 'info' || type === 'processing') ? 'block' : 'none';
            } else {
                statusLoader.style.display = showLoaderOverride ? 'block' : 'none';
            }
            
            const statusTypeColor = type === 'success' ? SUCCESS_COLOR_JS : (type === 'error' ? ERROR_COLOR_JS : ACCENT_CYAN_JS);
            statusSpan.parentElement.style.borderColor = statusTypeColor;
            await typeWriter(statusSpan, message, speed);
        }

    </script>
</body>
</html>
