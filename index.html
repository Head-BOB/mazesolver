<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&family=Crete+Round&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f8e0; /* Light moss green */
            --surface-color: #ffffff; /* White paper */
            --primary-color: #d2e8b0; /* Lighter green */
            --accent-color: #ff8c00; /* Bright orange for path */
            --text-color: #4a3b31; /* Dark brown */
            --text-muted-color: #7a6b61; /* Lighter brown */
            --button-bg-color: #78c850; /* Leaf green */
            --button-hover-bg-color: #58a030; /* Darker leaf green */
            --error-color: #e74c3c;
            --success-color: #2ecc71;
            --font-main: 'Nunito', sans-serif;
            --font-title: 'Crete Round', serif;
            --border-radius: 12px;
        }

        body {
            font-family: var(--font-main);
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-weight: 400;
            font-size: 15px;
            line-height: 1.6;
        }

        .main-container {
            background-color: var(--surface-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            width: 95%;
            max-width: 1100px;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        header h1 {
            font-family: var(--font-title);
            color: var(--text-color);
            text-align: center;
            font-size: 2.6em;
            margin-bottom: 5px;
        }
        header p {
            text-align: center;
            color: var(--text-muted-color);
            font-size: 1em;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .control-group {
            background-color: var(--primary-color);
            padding: 20px;
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group h3 {
            font-family: var(--font-title);
            color: var(--text-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 5px;
            border-bottom: 2px solid var(--text-muted-color);
            padding-bottom: 5px;
        }
        .control-group label {
            font-weight: 600;
            color: var(--text-muted-color);
            font-size: 0.9em;
        }

        .control-group input[type="file"],
        .control-group input[type="number"],
        .control-group button {
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 0.95em;
            transition: all 0.2s ease;
        }
        .control-group input[type="file"] {
             background-color: #f9f9f9;
        }
        .control-group input[type="file"]::file-selector-button {
            background-color: var(--button-bg-color);
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            font-family: var(--font-main);
            font-weight: 600;
        }
         .control-group input[type="number"]:focus {
            outline: none;
            border-color: var(--button-bg-color);
            box-shadow: 0 0 0 3px rgba(120, 200, 80, 0.2);
        }

        .control-group button {
            background-color: var(--button-bg-color);
            color: white;
            font-weight: 700;
            cursor: pointer;
            border: none;
        }
        .control-group button:hover {
            background-color: var(--button-hover-bg-color);
        }
        .control-group button.active {
            background-color: var(--error-color);
            color: white;
        }
        .control-group button.action-btn {
            background-color: var(--accent-color);
            color: white;
        }
        .control-group button.action-btn:hover {
            background-color: #e07c00;
        }
        .control-group button#downloadButton {
            background-color: #3498db; /* A nice blue for download */
        }
        .control-group button#downloadButton:hover {
            background-color: #2980b9;
        }


        .info-bar {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            padding: 12px;
            background-color: var(--primary-color);
            border-radius: var(--border-radius);
            font-size: 0.95em;
        }
        .info-bar p { margin: 5px;}
        .info-bar span {
            color: var(--text-color);
            font-weight: 700;
        }

        #status {
            padding: 15px;
            background-color: var(--primary-color);
            border-left: 5px solid var(--button-bg-color);
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            text-align: center;
            min-height: 24px;
            font-weight: 600;
        }

        .maze-display-area {
            position: relative;
            width: 100%;
            max-width: 700px; 
            margin: 0 auto; 
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            overflow: hidden; 
            background-color: #fff; 
        }
        #mazeImage {
            display: block;
            width: 100%; 
            height: auto;   
        }
        #solutionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            pointer-events: auto;
        }
        
        .processing-log-container {
            background-color: #333;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85em;
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            border: 1px solid #444;
            display: none; /* Hidden by default */
            margin-top: 15px;
        }
        .processing-log-container p {
            margin: 2px 0;
            white-space: pre-wrap;
        }
        .processing-log-container .log-entry-success { color: #0f0; }
        .processing-log-container .log-entry-warning { color: #ff0; }
        .processing-log-container .log-entry-error   { color: #f00; }
        .processing-log-container .log-entry-info    { color: #0ff; }


        @media (max-width: 768px) {
            body { font-size: 14px; }
            header h1 { font-size: 2em; }
            .main-container { padding: 15px; margin: 10px; }
            .controls-grid { grid-template-columns: 1fr; }
            .info-bar { flex-direction: column; align-items: center; gap: 5px; }
            .control-group {padding: 15px;}
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>Maze Solver</h1>
            <p>Venture forth! Upload your labyrinth, and let's chart a course to freedom!</p>
        </header>

        <div class="controls-grid">
            <div class="control-group">
                <h3>1. The Map</h3>
                <label for="imageUpload">Upload Maze Image:</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>

            <div class="control-group">
                <h3>2. Scout's Tools</h3>
                <label for="cellSize">Detail Level (Cell Size px):</label>
                <input type="number" id="cellSize" value="3" min="1" max="50" title="Smaller for more detail, larger for speed.">
                <label for="pathThreshold">Path Clarity (Brightness 0-255):</label>
                <input type="number" id="pathThreshold" value="128" min="0" max="255" title="Higher for lighter paths.">
            </div>

            <div class="control-group">
                <h3>3. Mark Your Trail</h3>
                <button id="autoDetectButton">Auto-Detect Start/End</button>
                <button id="setStartButton">Set Start Manually</button>
                <button id="setEndButton">Set End Manually</button>
            </div>
             <div class="control-group">
                <h3>4. Begin Quest!</h3>
                <button id="solveShortestButton" class="action-btn">Find Shortest Path</button>
                <button id="findAllPathsButton" class="action-btn">Explore All Routes (Careful!)</button>
                <button id="downloadButton" style="display:none;">Download Solved Image</button>
            </div>
        </div>

        <div class="info-bar">
            <p>Start: <span id="startPointInfo">Not set</span></p>
            <p>End: <span id="endPointInfo">Not set</span></p>
            <p>Paths Found: <span id="pathsFoundInfo">N/A</span></p>
        </div>
        
        <div id="status">Ready to explore! Upload a map to begin.</div>
        
        <div class="processing-log-container" id="processingLog"></div>

        <div class="maze-display-area">
            <img id="mazeImage" src="#" alt="Uploaded Maze" style="display:none;">
            <canvas id="solutionCanvas"></canvas>
        </div>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const mazeImage = document.getElementById('mazeImage');
        const solutionCanvas = document.getElementById('solutionCanvas');
        const ctx = solutionCanvas.getContext('2d');
        
        const cellSizeInput = document.getElementById('cellSize');
        const pathThresholdInput = document.getElementById('pathThreshold');
        const autoDetectButton = document.getElementById('autoDetectButton');
        const setStartButton = document.getElementById('setStartButton');
        const setEndButton = document.getElementById('setEndButton');
        const solveShortestButton = document.getElementById('solveShortestButton');
        const findAllPathsButton = document.getElementById('findAllPathsButton');
        const downloadButton = document.getElementById('downloadButton');
        const statusDiv = document.getElementById('status');
        const startPointInfo = document.getElementById('startPointInfo');
        const endPointInfo = document.getElementById('endPointInfo');
        const pathsFoundInfo = document.getElementById('pathsFoundInfo');
        const processingLogDiv = document.getElementById('processingLog');

        let originalImage = null;
        let imageDisplayedWidth = 0;
        let imageDisplayedHeight = 0;
        let mazeGrid = [];
        let gridWidth, gridHeight;
        let startCoords = null;
        let endCoords = null;
        let settingMode = null; 
        let currentSolutionPath = null;

        const ACCENT_COLOR_JS = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
        const SUCCESS_COLOR_JS = getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim();
        const ERROR_COLOR_JS = getComputedStyle(document.documentElement).getPropertyValue('--error-color').trim();
        const BUTTON_BG_JS = getComputedStyle(document.documentElement).getPropertyValue('--button-bg-color').trim();

        const MAX_PATHS_TO_FIND = 500;
        const MAX_DFS_SEARCH_TIME_MS = 20000; 
        let logInterval = null;

        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    mazeImage.src = e.target.result;
                    mazeImage.style.display = 'block';
                    originalImage = new Image();
                    originalImage.onload = () => {
                        solutionCanvas.width = originalImage.naturalWidth;
                        solutionCanvas.height = originalImage.naturalHeight;
                        imageDisplayedWidth = mazeImage.offsetWidth;
                        imageDisplayedHeight = mazeImage.offsetHeight;
                        ctx.clearRect(0, 0, solutionCanvas.width, solutionCanvas.height);
                        resetState();
                        updateStatus('Map loaded. Adjust tools or mark your trail.', BUTTON_BG_JS);
                        downloadButton.style.display = 'none';
                        currentSolutionPath = null;
                    }
                    originalImage.src = e.target.result;
                }
                reader.readAsDataURL(file);
            }
        });

        window.addEventListener('resize', () => {
            if (originalImage && mazeImage.style.display === 'block') {
                imageDisplayedWidth = mazeImage.offsetWidth;
                imageDisplayedHeight = mazeImage.offsetHeight;
                drawPointsAndPath();
            }
        });
        
        function resetState() {
            mazeGrid = [];
            startCoords = null;
            endCoords = null;
            settingMode = null;
            currentSolutionPath = null;
            startPointInfo.textContent = 'Not set';
            endPointInfo.textContent = 'Not set';
            pathsFoundInfo.textContent = 'N/A';
            setStartButton.classList.remove('active');
            setEndButton.classList.remove('active');
            if(solutionCanvas.width > 0 && solutionCanvas.height > 0) {
                ctx.clearRect(0, 0, solutionCanvas.width, solutionCanvas.height);
            }
            updateStatus('Ready for a new adventure!', BUTTON_BG_JS);
            downloadButton.style.display = 'none';
            processingLogDiv.style.display = 'none';
            processingLogDiv.innerHTML = '';
        }
        
        function startProcessingLog(initialMessages) {
            processingLogDiv.innerHTML = '';
            processingLogDiv.style.display = 'block';
            let logIndex = 0;
            initialMessages.forEach(msg => addLogEntry(msg.text, msg.type));
            
            const dynamicMessages = [
                "... scanning for hidden passages ...",
                "... consulting ancient scrolls ...",
                "... checking for troll roadblocks ...",
                "... sharpening the pathfinding pencil ...",
                "... ensuring map coordinates are aligned ...",
                "... calibrating compass ...",
                "... analyzing terrain for optimal routes ...",
                "... avoiding dragon lairs (mostly) ...",
                "... seeking guidance from the forest spirits ...",
                "... almost there, brave adventurer!"
            ];
            logInterval = setInterval(() => {
                if (logIndex < dynamicMessages.length) {
                    addLogEntry(dynamicMessages[logIndex], 'info');
                    logIndex++;
                } else {
                     addLogEntry("...finalizing calculations...", 'info');
                     clearInterval(logInterval);
                }
            }, 700); 
        }

        function stopProcessingLog() {
            clearInterval(logInterval);
        }

        function addLogEntry(message, type = 'info') {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (type === 'success') p.classList.add('log-entry-success');
            else if (type === 'warning') p.classList.add('log-entry-warning');
            else if (type === 'error') p.classList.add('log-entry-error');
            else p.classList.add('log-entry-info');
            processingLogDiv.appendChild(p);
            processingLogDiv.scrollTop = processingLogDiv.scrollHeight;
        }
        
        autoDetectButton.addEventListener('click', () => {
            if (!originalImage) { updateStatus('Upload a map first!', ERROR_COLOR_JS); return; }
            startProcessingLog([
                {text: "Auto-detection sequence initiated.", type: 'info'},
                {text: "Analyzing map boundaries...", type: 'info'}
            ]);
            setTimeout(() => {
                buildMazeGrid();
                if (mazeGrid.length === 0 || (mazeGrid[0] && mazeGrid[0].length === 0)) {
                     addLogEntry('Grid construction failed for auto-detection.', 'error');
                     updateStatus('Error: Could not build grid for auto-detection.', ERROR_COLOR_JS);
                     stopProcessingLog();
                     return;
                }
                performAutoDetection();
                drawPointsAndPath();
                stopProcessingLog();
                 addLogEntry('Auto-detection complete.', 'success');
            }, 50);
        });

        function performAutoDetection() {
            let S_found = false, E_found = false;
            startCoords = null; endCoords = null;

            for (let x = 0; x < gridWidth; x++) { if (mazeGrid[0][x]) { startCoords = {x,y:0}; S_found=true; addLogEntry(`Possible start found at top edge: (${x},0)`, 'info'); break; }}
            if(!S_found){ for (let y = 0; y < gridHeight; y++) { if (mazeGrid[y][0]) { startCoords = {x:0,y}; S_found=true; addLogEntry(`Possible start found at left edge: (0,${y})`, 'info'); break; }}}

            for (let x = gridWidth - 1; x >= 0; x--) { if (mazeGrid[gridHeight-1][x]) { endCoords = {x,y:gridHeight-1}; E_found=true; addLogEntry(`Possible end found at bottom edge: (${x},${gridHeight-1})`, 'info'); break; }}
            if(!E_found){ for (let y = gridHeight - 1; y >= 0; y--) { if (mazeGrid[y][gridWidth-1]) { endCoords = {x:gridWidth-1,y}; E_found=true; addLogEntry(`Possible end found at right edge: (${gridWidth-1},${y})`, 'info'); break; }}}
            
            if (startCoords) startPointInfo.textContent = `(${startCoords.x}, ${startCoords.y})`; else { startPointInfo.textContent = 'Not found'; addLogEntry('Start point not found on borders.', 'warning');}
            if (endCoords) endPointInfo.textContent = `(${endCoords.x}, ${endCoords.y})`; else { endPointInfo.textContent = 'Not found'; addLogEntry('End point not found on borders.', 'warning');}
            
            if(S_found && E_found) updateStatus('Auto-detected trail markers!', SUCCESS_COLOR_JS);
            else if (S_found || E_found) updateStatus('Partially detected markers. Check and set manually if needed.', BUTTON_BG_JS);
            else updateStatus('Auto-detection failed. Please mark your trail manually.', ERROR_COLOR_JS);
        }

        setStartButton.addEventListener('click', () => {
            if (!originalImage) { updateStatus('Upload a map first!', ERROR_COLOR_JS); return; }
            settingMode = 'start';
            setStartButton.classList.add('active');
            setEndButton.classList.remove('active');
            updateStatus('Click on the map to mark the START of your journey.', BUTTON_BG_JS);
        });

        setEndButton.addEventListener('click', () => {
            if (!originalImage) { updateStatus('Upload a map first!', ERROR_COLOR_JS); return; }
            settingMode = 'end';
            setEndButton.classList.add('active');
            setStartButton.classList.remove('active');
            updateStatus('Click on the map to mark your DESTINATION.', BUTTON_BG_JS);
        });

        solutionCanvas.addEventListener('click', (event) => {
            if (!originalImage || !settingMode) return;
            const rect = solutionCanvas.getBoundingClientRect(); 
            const clickX_on_canvas = event.clientX - rect.left;
            const clickY_on_canvas = event.clientY - rect.top;
            const scaleX = solutionCanvas.width / imageDisplayedWidth;
            const scaleY = solutionCanvas.height / imageDisplayedHeight;
            const x_on_image = clickX_on_canvas * scaleX;
            const y_on_image = clickY_on_canvas * scaleY;
            const cellSize = parseInt(cellSizeInput.value);
            const gridX = Math.floor(x_on_image / cellSize);
            const gridY = Math.floor(y_on_image / cellSize);

            if (settingMode === 'start') {
                startCoords = { x: gridX, y: gridY };
                startPointInfo.textContent = `(${gridX}, ${gridY})`;
                updateStatus('Start point marked. Now mark your destination or begin quest!', BUTTON_BG_JS);
                setStartButton.classList.remove('active');
            } else if (settingMode === 'end') {
                endCoords = { x: gridX, y: gridY };
                endPointInfo.textContent = `(${gridX}, ${gridY})`;
                updateStatus('Destination marked. Ready to begin quest!', BUTTON_BG_JS);
                setEndButton.classList.remove('active');
            }
            settingMode = null; 
            currentSolutionPath = null; 
            downloadButton.style.display = 'none';
            drawPointsAndPath();
        });
        
        function drawPointsAndPath() {
            if(solutionCanvas.width === 0 || solutionCanvas.height === 0) return;
            ctx.clearRect(0, 0, solutionCanvas.width, solutionCanvas.height); 
            const cellSize = parseInt(cellSizeInput.value);
            const pointRadius = Math.max(3, cellSize * 0.35); 

            if (currentSolutionPath) {
                drawPath(currentSolutionPath, ACCENT_COLOR_JS, cellSize);
            }

            if (startCoords) {
                ctx.fillStyle = SUCCESS_COLOR_JS;
                ctx.beginPath();
                ctx.arc(startCoords.x * cellSize + cellSize / 2, startCoords.y * cellSize + cellSize / 2, pointRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
            if (endCoords) {
                ctx.fillStyle = ERROR_COLOR_JS;
                ctx.beginPath();
                ctx.arc(endCoords.x * cellSize + cellSize / 2, endCoords.y * cellSize + cellSize / 2, pointRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function drawPath(path, color, cellSize) {
            if (!path || path.length === 0) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = Math.max(2, Math.floor(cellSize * 0.4));
            ctx.lineCap = "round"; ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(path[0].x * cellSize + cellSize / 2, path[0].y * cellSize + cellSize / 2);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x * cellSize + cellSize / 2, path[i].y * cellSize + cellSize / 2);
            }
            ctx.stroke();
        }

        function commonSolvePreamble() {
            if (!originalImage) { updateStatus('Upload a map first.', ERROR_COLOR_JS); return false; }
            if (!startCoords || !endCoords) { updateStatus('Mark both start and end points on your trail.', ERROR_COLOR_JS); return false; }
            currentSolutionPath = null; 
            downloadButton.style.display = 'none';
            pathsFoundInfo.textContent = 'N/A';
            startProcessingLog([
                {text: "Quest initiated!", type: 'success'},
                {text: "Preparing map grid from image data...", type: 'info'}
            ]);
            return true;
        }

        solveShortestButton.addEventListener('click', () => {
            if(!commonSolvePreamble()) return;
            setTimeout(() => { 
                buildMazeGrid();
                if (!validateGridAndPoints()) { stopProcessingLog(); return; }
                addLogEntry('Grid constructed. Searching for the most direct route...', 'info');
                setTimeout(() => { 
                    currentSolutionPath = solveBFS();
                    drawPointsAndPath();
                    if (currentSolutionPath) {
                        pathsFoundInfo.textContent = '1 (shortest)';
                        downloadButton.style.display = 'block';
                        addLogEntry('Shortest path illuminated!', 'success');
                    } else {
                        addLogEntry('No direct path found.', 'warning');
                    }
                    stopProcessingLog();
                }, 50);
            }, 50);
        });
        
        findAllPathsButton.addEventListener('click', () => {
            if(!commonSolvePreamble()) return;
            if (!confirm("WARNING: Exploring all routes can be a long journey for complex maps and might not find all if the map is too vast or time runs out. Continue exploration?")) {
                stopProcessingLog();
                addLogEntry('Exploration of all routes cancelled by user.', 'warning');
                updateStatus('Exploration cancelled.', BUTTON_BG_JS);
                return;
            }
            setTimeout(() => { 
                buildMazeGrid();
                if (!validateGridAndPoints()) { stopProcessingLog(); return; }
                addLogEntry('Grid constructed. Commencing deep exploration for all possible routes...', 'info');
                addLogEntry(`(Search limits: ${MAX_PATHS_TO_FIND} paths or ${MAX_DFS_SEARCH_TIME_MS/1000}s)`, 'info');
                setTimeout(() => { 
                    const result = solveDFS_findAllPaths();
                    pathsFoundInfo.textContent = `${result.paths.length}${result.limitReached ? `+ (${result.limitType} limit)`: ''}`;
                    if (result.paths.length > 0) {
                        currentSolutionPath = result.paths[0];
                        drawPointsAndPath();
                        updateStatus(`Found ${result.paths.length} routes${result.limitReached ? ' (search limited)' : ''}. Displaying one.`, SUCCESS_COLOR_JS);
                        downloadButton.style.display = 'block';
                        addLogEntry(`Exploration yielded ${result.paths.length} routes. One is now marked.`, 'success');
                        if(result.limitReached) addLogEntry(`Search was terminated due to ${result.limitType} limit. Not all paths may have been found.`, 'warning');
                    } else {
                        drawPointsAndPath(); 
                        updateStatus('No routes found between these points.', ERROR_COLOR_JS);
                        addLogEntry('Deep exploration found no connecting routes.', 'warning');
                    }
                    stopProcessingLog();
                }, 50);
            }, 50);
        });
        
        function validateGridAndPoints() {
            if (mazeGrid.length === 0 || (mazeGrid[0] && mazeGrid[0].length === 0)) {
                 updateStatus('Error: Could not decipher the map grid. Check tools.', ERROR_COLOR_JS); 
                 addLogEntry('Map grid construction failed.', 'error');
                 return false;
            }
            if (!isValidPoint(startCoords) || !mazeGrid[startCoords.y][startCoords.x]) {
                 updateStatus('Start marker is on an impassable area or off the map.', ERROR_COLOR_JS);
                 addLogEntry('Start marker invalid.', 'error');
                 return false;
            }
            if (!isValidPoint(endCoords) || !mazeGrid[endCoords.y][endCoords.x]) {
                 updateStatus('Destination marker is on an impassable area or off the map.', ERROR_COLOR_JS);
                 addLogEntry('Destination marker invalid.', 'error');
                 return false;
            }
            addLogEntry('Map grid and markers validated.', 'success');
            return true;
        }

        function isValidPoint(coord) {
            return coord && coord.y >= 0 && coord.y < gridHeight && coord.x >= 0 && coord.x < gridWidth;
        }

        function buildMazeGrid() {
            const cellSize = parseInt(cellSizeInput.value);
            const pathThreshold = parseInt(pathThresholdInput.value);
            gridWidth = Math.floor(originalImage.naturalWidth / cellSize);
            gridHeight = Math.floor(originalImage.naturalHeight / cellSize);
            if (gridWidth <= 0 || gridHeight <= 0) { mazeGrid = []; return; }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImage.naturalWidth;
            tempCanvas.height = originalImage.naturalHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(originalImage, 0, 0);
            mazeGrid = [];
            for (let y = 0; y < gridHeight; y++) {
                const row = [];
                for (let x = 0; x < gridWidth; x++) {
                    const sx = x * cellSize; const sy = y * cellSize;
                    const effW = Math.min(cellSize, originalImage.naturalWidth - sx);
                    const effH = Math.min(cellSize, originalImage.naturalHeight - sy);
                    if (effW <= 0 || effH <= 0) { row.push(0); continue; }
                    try {
                        const imageData = tempCtx.getImageData(sx, sy, effW, effH);
                        const data = imageData.data;
                        let sumBrightness = 0; let pixelCount = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            sumBrightness += (data[i] + data[i+1] + data[i+2]) / 3;
                            pixelCount++;
                        }
                        const avgBrightness = pixelCount > 0 ? sumBrightness / pixelCount : 0;
                        row.push(avgBrightness > pathThreshold ? 1 : 0);
                    } catch (e) { row.push(0); }
                }
                mazeGrid.push(row);
            }
        }

        function solveBFS() {
            const queue = [{ x: startCoords.x, y: startCoords.y, path: [] }];
            const visited = new Set([`${startCoords.x},${startCoords.y}`]);
            const directions = [ { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 } ];
            while (queue.length > 0) {
                const current = queue.shift();
                const { x, y, path } = current;
                if (x === endCoords.x && y === endCoords.y) {
                    updateStatus('The most direct path is clear!', SUCCESS_COLOR_JS);
                    return path.concat([{ x, y }]);
                }
                for (const dir of directions) {
                    const nextX = x + dir.dx; const nextY = y + dir.dy;
                    if (isValidPoint({x:nextX, y:nextY}) && mazeGrid[nextY][nextX] === 1 && !visited.has(`${nextX},${nextY}`)) {
                        visited.add(`${nextX},${nextY}`);
                        queue.push({ x: nextX, y: nextY, path: path.concat([{x,y}]) });
                    }
                }
            }
            updateStatus('No direct path found on this map.', ERROR_COLOR_JS);
            return null;
        }
        
        function solveDFS_findAllPaths() {
            const allPathsFound = [];
            const currentPathStack = [];
            const visitedInThisPath = new Set();
            const startTime = Date.now();
            let limitReachedType = null;
            
            function dfsRecursive(currX, currY) {
                if (allPathsFound.length >= MAX_PATHS_TO_FIND) {
                    limitReachedType = 'max paths';
                    return;
                }
                if (Date.now() - startTime > MAX_DFS_SEARCH_TIME_MS) {
                    limitReachedType = 'time limit';
                    return;
                }

                currentPathStack.push({x: currX, y: currY});
                visitedInThisPath.add(`${currX},${currY}`);

                if (currX === endCoords.x && currY === endCoords.y) {
                    allPathsFound.push([...currentPathStack]); 
                    if(allPathsFound.length % 50 === 0) { // Log progress occasionally
                        addLogEntry(`Found ${allPathsFound.length} routes so far...`, 'info');
                    }
                } else {
                    const directions = [ { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 } ]; // Could shuffle for variety
                    for (const dir of directions) {
                        if (limitReachedType) break; // Stop if limit hit in deeper recursion
                        const nextX = currX + dir.dx;
                        const nextY = currY + dir.dy;
                        if (isValidPoint({x:nextX, y:nextY}) && mazeGrid[nextY][nextX] === 1 && !visitedInThisPath.has(`${nextX},${nextY}`)) {
                            dfsRecursive(nextX, nextY);
                        }
                    }
                }
                visitedInThisPath.delete(`${currX},${currY}`);
                currentPathStack.pop();
            }

            dfsRecursive(startCoords.x, startCoords.y);
            return { paths: allPathsFound, limitReached: !!limitReachedType, limitType: limitReachedType };
        }
        
        downloadButton.addEventListener('click', () => {
            if (!originalImage || !currentSolutionPath) {
                updateStatus('No solved maze to download.', ERROR_COLOR_JS);
                return;
            }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImage.naturalWidth;
            tempCanvas.height = originalImage.naturalHeight;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.drawImage(originalImage, 0, 0);
            
            const cellSize = parseInt(cellSizeInput.value);
            if (currentSolutionPath && currentSolutionPath.length > 0) {
                 tempCtx.strokeStyle = ACCENT_COLOR_JS;
                 tempCtx.lineWidth = Math.max(2, Math.floor(cellSize * 0.4));
                 tempCtx.lineCap = "round"; tempCtx.lineJoin = "round";
                 tempCtx.beginPath();
                 tempCtx.moveTo(currentSolutionPath[0].x * cellSize + cellSize / 2, currentSolutionPath[0].y * cellSize + cellSize / 2);
                 for (let i = 1; i < currentSolutionPath.length; i++) {
                     tempCtx.lineTo(currentSolutionPath[i].x * cellSize + cellSize / 2, currentSolutionPath[i].y * cellSize + cellSize / 2);
                 }
                 tempCtx.stroke();
            }
            
            const dataURL = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'solved_maze.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            updateStatus('Solved map downloaded!', SUCCESS_COLOR_JS);
        });
        
        function updateStatus(message, borderColor) {
            statusDiv.textContent = message;
            statusDiv.style.borderColor = borderColor || BUTTON_BG_JS;
        }

    </script>
</body>
</html>
